"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var React = _interopRequire(require("react"));

var Chartist = _interopRequire(require("chartist"));

var classnames = _interopRequire(require("classnames"));

var Chart = (function (_React$Component) {
  function Chart(props) {
    _classCallCheck(this, Chart);

    _React$Component.call(this, props);

    this.state = {
      dataName: "",
      dataValue: ""
    };

    this.onMouseOver = this.onMouseOver.bind(this);
  }

  _inherits(Chart, _React$Component);

  Chart.prototype.componentDidMount = function componentDidMount() {
    this.updateChart(this.props);
  };

  Chart.prototype.componentWillReceiveProps = function componentWillReceiveProps(newProps) {
    this.updateChart(newProps);
  };

  Chart.prototype.componentWillUnmount = function componentWillUnmount() {
    this.chartist.detach();
  };

  Chart.prototype.render = function render() {
    return React.createElement(
      "div",
      null,
      React.createElement("div", { ref: "chart",
        className: classnames("ct-chart", this.props.classnames),
        onMouseOver: this.onMouseOver }),
      React.createElement(
        "div",
        { className: "ct-tooltip" },
        React.createElement(
          "span",
          null,
          this.state.dataName
        ),
        React.createElement(
          "span",
          null,
          this.state.dataValue
        )
      )
    );
  };

  Chart.prototype.updateChart = function updateChart(props) {
    var _this = this;

    var type = props.type;
    var data = props.data;
    var _props$options = props.options;
    var options = _props$options === undefined ? {} : _props$options;
    var _props$responsiveOptions = props.responsiveOptions;
    var responsiveOptions = _props$responsiveOptions === undefined ? [] : _props$responsiveOptions;
    var _props$events = props.events;
    var events = _props$events === undefined ? {} : _props$events;
    var create = function () {
      _this.chartist = new Chartist[type](React.findDOMNode(_this.refs.chart), data, options, responsiveOptions);

      Object.keys(events).forEach(function (x) {
        return _this.chartist.on(x, events[x].bind(_this.chartist));
      });
    };

    this.chartist ? this.chartist.update(data, options, true) : data.series ? create() : null;
  };

  Chart.prototype.onMouseOver = function onMouseOver(_ref) {
    var target = _ref.target;

    var dataName = target.parentNode.attributes["ct:name"] ? target.parentNode.attributes["ct:name"].value : "",
        dataValue = target.attributes["ct:value"] ? target.attributes["ct:value"].value : "";

    this.setState({
      dataName: dataName,
      dataValue: dataValue
    });
  };

  return Chart;
})(React.Component);

module.exports = Chart;

Chart.propTypes = {
  type: React.PropTypes.string.isRequired,
  classnames: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object]),
  data: React.PropTypes.shape({
    labels: React.PropTypes.array,
    series: React.PropTypes.array
  }),
  options: React.PropTypes.object,
  responsiveOptions: React.PropTypes.array,
  events: React.PropTypes.object
};